# LeetCode 每日一题

### LC.2562. 找出数组的串联值 - 2023-10-12

```java
	// lc.2562. 找出数组的串联值
    // 将数字拼接直接进行计算  不做 数字 -> 字符串 -> 数字 的转化
    // 直接 numA * 10^数位(numB) + numB
    public long findTheArrayConcVal(int[] nums) {
        long ans = 0;
        int left = 0;
        int right = nums.length - 1;
        while (left < right){
            long serVal = (long) (nums[left] * Math.pow(10, (int)Math.log10(nums[right]) + 1) + nums[right]);
            ans += serVal;
            left++;
            right--;
        }
        if (left == right)
            ans += nums[left];
        return ans;
    }
```

### LC.1488. 避免洪水泛滥 -2023-10-13

```java
	// lc.1488. 避免洪水泛滥
    // 存储不下雨的天，当出现重复天数时拿来用
    // 注意其备用天数需要大于上次下雨的日期
    public int[] avoidFlood(int[] rains) {
        int n = rains.length;
        int[] ans = new int[n];
        Arrays.fill(ans, 1);
        HashMap<Integer, Integer> map = new HashMap<>();
        TreeSet<Integer> set = new TreeSet<>();
        for (int i = 0; i < n; i++) {
            if (rains[i] == 0)
                set.add(i);
            else {
                ans[i] = -1;
                if (!map.containsKey(rains[i])){
                    map.put(rains[i], i);
                }else {
                    int last = map.get(rains[i]);
                    Integer index = set.ceiling(last);
                    if (index == null)
                        return new int[0];
                    set.remove(index);
                    ans[index] = rains[i];
                    map.put(rains[i], i);
                }
            }
        }
        return ans;
    }
```

### LC.136. 只出现一次的数字 -2023-10-14

```java
	// lc.136. 只出现一次的数字
    // 要求 O(n) + O(1)
    // 通解为分别处理每个数字的二进制位 然后还原该数字
    // 由于只有一个数出现一次, 其他数均出现两次
    // 本题可以利用异或的性质: A ^ A = 0   A ^ 0 = A
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int num : nums)
            ans ^= num;
        return ans;
    }
```

### LC.137. 只出现一次的数字 II -2023-10-15

```java
	// lc.137. 只出现一次的数字 II
    // 要求O(n) O(1)
    // 查找数字通解 根据每个数位的数字情况来判断一次出现数字的数位表示情况
    // O(C * n) = O(n)
    public int singleNumber(int[] nums) {
        int ans = 0;
        int n = nums.length;
        for (int i = 0; i < 32; i++) {
            int num = 0;
            for (int j = 0; j < n; j++) {
                num += (nums[j] >> i) &  1;
            }
            ans |= (num % 3) << i;
            //  if (num % 3 != 0)
            //      ans |= 1 << i;
        }
        return ans;
    }
```

### LC..260. 只出现一次的数字 III -2023-10-16

```java
	// lc.260. 只出现一次的数字 III
    // 要求O(n) O(1)
    // 两个出现一次的数 和 若干个出现两次(偶数次)的数
    // 很容易想到将偶数次消除 最终获得 N =  A^B的结果
    // 由于 A != B 故 存在 ni = 1 ni是N的数位
    // 那么就可以根据ni的取值将出现的数字进行划分
    // 两个组内各自异或的结果即为所求结果
    // x & (-x): 保留二进制下最右侧1其余置0 low bit
    // x & (x-1): 消除二进制下最后出现1的位置 其余保持不变
    public int[] singleNumber(int[] nums) {
        int n = nums.length;
        int xor = 0;
        for (int i = 0; i < n; i++)
            xor ^= nums[i];
        int lowBit = xor & (-xor);
        int ans1 = 0;
        int ans2 = 0;
        for (int i = 0; i < n; i++) {
            if ((lowBit & nums[i]) != 0)
                ans1 ^= nums[i];
            else
                ans2 ^= nums[i];
        }
        return new int[]{ans1, ans2};
    }
```

### LC..2652. 倍数求和 -2023-10-17

```java
	// lc.2652. 倍数求和
    // 很容易想到O(n) 遍历的算法
    // 对于[1, n] 区间内的数 能被x整除的数有 C = [n/x] (Gauss) 个
    // 等差数列求和得到 C * (C + 1) * x / 2
    // {A} or {B} or {C} = {A} + {B} + {C} - {AB} - {AC} - {BC} + {ABC}
    public int sumOfMultiples(int n) {
        return sum(n,3) + sum(n,5) + sum(n, 7) - sum(n, 3 * 5) - sum(n, 3 * 7) -sum(n,5 * 7) + sum(n, 3 * 5 * 7);
    }

    public int sum(int n, int x){
        return (n / x + 1) * (n / x) * x / 2;
    }
```

### LC.2530. 执行 K 次操作后的最大分数 -2023-10-18

```java
	// lc.2530. 执行 K 次操作后的最大分数
    // TopK 但是元素会有新元素添加 更新堆元素即可
    // 优化点: ceil(x / 3) -> (x + 2) / 3 避免浮点数运算
    // simple proof(Not rigorous):
    // ceil(A/B) <=> (int)((A + B - 1) / B)
    // A = k * B + C
    // A / B = K + C / B  in math
    // (int) ((A + B -1) / B) = K + (int)((C + B - 1) / B)
    // ceil(A/B) = K if C == 0
    //           = K + 1 if C >= 1
    // (int) ((A + B -1) / B)  = K if C == 0
    //                         = K + 1 if C >= 1
    // (int) ((A + B -1) / B) <=> ceil(A/B)
    public long maxKelements(int[] nums, int k) {
        PriorityQueue<Integer> heap = new PriorityQueue<>((x,y)->y-x);
        int n = nums.length;
        long ans = 0;
        for (int i = 0; i < n; i++) {
            heap.offer(nums[i]);
        }
        while (k > 0){
            int maxValue = heap.poll();
            ans += maxValue;
            heap.offer((maxValue + 2) / 3 );
            k--;
        }
        return ans;
    }
```

### LC..1726. 同积元组 -2023-10-19

```java
	// lc.1726. 同积元组
    // 第一感觉 排序 最后发现好像不需要
    // 由于 nums[i] >= 1 且互不相同 可以获得两两组合的乘积
    // 然后累计每个乘积对应的基数 C2n   可以确定 (a, b) (c, d) 不存在重复子元素
    // 由于 num[i] <= 10^4 故乘积不会溢出
    // 由于是组成(a,b,c,d)的元组  两组数选择位置有2种情况 各自组内位置 2 * 2种
    // 故结果为 C2n * 2 * 2 * 2 = n * (n - 1) * 4;
    public int tupleSameProduct(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int n = nums.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int mul = nums[i] * nums[j];
                int base = map.getOrDefault(mul, 0);
                map.put(mul, base + 1);
            }
        }
        for (Integer v: map.values()){
            ans += v * (v-1);
        }
        return ans * 4;
    }
```

