# LeetCode 每日一题

## LC.2562. 找出数组的串联值 - 2023-10-12

```java
	// lc.2562. 找出数组的串联值
    // 将数字拼接直接进行计算  不做 数字 -> 字符串 -> 数字 的转化
    // 直接 numA * 10^数位(numB) + numB
    public long findTheArrayConcVal(int[] nums) {
        long ans = 0;
        int left = 0;
        int right = nums.length - 1;
        while (left < right){
            long serVal = (long) (nums[left] * Math.pow(10, (int)Math.log10(nums[right]) + 1) + nums[right]);
            ans += serVal;
            left++;
            right--;
        }
        if (left == right)
            ans += nums[left];
        return ans;
    }
```

## LC.1488. 避免洪水泛滥 -2023-10-13

```java
	// lc.1488. 避免洪水泛滥
    // 存储不下雨的天，当出现重复天数时拿来用
    // 注意其备用天数需要大于上次下雨的日期
    public int[] avoidFlood(int[] rains) {
        int n = rains.length;
        int[] ans = new int[n];
        Arrays.fill(ans, 1);
        HashMap<Integer, Integer> map = new HashMap<>();
        TreeSet<Integer> set = new TreeSet<>();
        for (int i = 0; i < n; i++) {
            if (rains[i] == 0)
                set.add(i);
            else {
                ans[i] = -1;
                if (!map.containsKey(rains[i])){
                    map.put(rains[i], i);
                }else {
                    int last = map.get(rains[i]);
                    Integer index = set.ceiling(last);
                    if (index == null)
                        return new int[0];
                    set.remove(index);
                    ans[index] = rains[i];
                    map.put(rains[i], i);
                }
            }
        }
        return ans;
    }
```

### LC.136. 只出现一次的数字 -2023-10-14

```java
	// lc.136. 只出现一次的数字
    // 要求 O(n) + O(1)
    // 通解为分别处理每个数字的二进制位 然后还原该数字
    // 由于只有一个数出现一次, 其他数均出现两次
    // 本题可以利用异或的性质: A ^ A = 0   A ^ 0 = A
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int num : nums)
            ans ^= num;
        return ans;
    }
```

