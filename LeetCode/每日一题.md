# LeetCode 每日一题

### LC.2562. 找出数组的串联值 - 2023-10-12

```java
	// lc.2562. 找出数组的串联值
    // 将数字拼接直接进行计算  不做 数字 -> 字符串 -> 数字 的转化
    // 直接 numA * 10^数位(numB) + numB
    public long findTheArrayConcVal(int[] nums) {
        long ans = 0;
        int left = 0;
        int right = nums.length - 1;
        while (left < right){
            long serVal = (long) (nums[left] * Math.pow(10, (int)Math.log10(nums[right]) + 1) + nums[right]);
            ans += serVal;
            left++;
            right--;
        }
        if (left == right)
            ans += nums[left];
        return ans;
    }
```

### LC.1488. 避免洪水泛滥 -2023-10-13

```java
	// lc.1488. 避免洪水泛滥
    // 存储不下雨的天，当出现重复天数时拿来用
    // 注意其备用天数需要大于上次下雨的日期
    public int[] avoidFlood(int[] rains) {
        int n = rains.length;
        int[] ans = new int[n];
        Arrays.fill(ans, 1);
        HashMap<Integer, Integer> map = new HashMap<>();
        TreeSet<Integer> set = new TreeSet<>();
        for (int i = 0; i < n; i++) {
            if (rains[i] == 0)
                set.add(i);
            else {
                ans[i] = -1;
                if (!map.containsKey(rains[i])){
                    map.put(rains[i], i);
                }else {
                    int last = map.get(rains[i]);
                    Integer index = set.ceiling(last);
                    if (index == null)
                        return new int[0];
                    set.remove(index);
                    ans[index] = rains[i];
                    map.put(rains[i], i);
                }
            }
        }
        return ans;
    }
```

### LC.136. 只出现一次的数字 -2023-10-14

```java
	// lc.136. 只出现一次的数字
    // 要求 O(n) + O(1)
    // 通解为分别处理每个数字的二进制位 然后还原该数字
    // 由于只有一个数出现一次, 其他数均出现两次
    // 本题可以利用异或的性质: A ^ A = 0   A ^ 0 = A
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int num : nums)
            ans ^= num;
        return ans;
    }
```

### LC.137. 只出现一次的数字 II -2023-10-15

```java
	// lc.137. 只出现一次的数字 II
    // 要求O(n) O(1)
    // 查找数字通解 根据每个数位的数字情况来判断一次出现数字的数位表示情况
    // O(C * n) = O(n)
    public int singleNumber(int[] nums) {
        int ans = 0;
        int n = nums.length;
        for (int i = 0; i < 32; i++) {
            int num = 0;
            for (int j = 0; j < n; j++) {
                num += (nums[j] >> i) &  1;
            }
            ans |= (num % 3) << i;
            //  if (num % 3 != 0)
            //      ans |= 1 << i;
        }
        return ans;
    }
```

### LC..260. 只出现一次的数字 III -2023-10-16

```java
	// lc.260. 只出现一次的数字 III
    // 要求O(n) O(1)
    // 两个出现一次的数 和 若干个出现两次(偶数次)的数
    // 很容易想到将偶数次消除 最终获得 N =  A^B的结果
    // 由于 A != B 故 存在 ni = 1 ni是N的数位
    // 那么就可以根据ni的取值将出现的数字进行划分
    // 两个组内各自异或的结果即为所求结果
    // x & (-x): 保留二进制下最右侧1其余置0 low bit
    // x & (x-1): 消除二进制下最后出现1的位置 其余保持不变
    public int[] singleNumber(int[] nums) {
        int n = nums.length;
        int xor = 0;
        for (int i = 0; i < n; i++)
            xor ^= nums[i];
        int lowBit = xor & (-xor);
        int ans1 = 0;
        int ans2 = 0;
        for (int i = 0; i < n; i++) {
            if ((lowBit & nums[i]) != 0)
                ans1 ^= nums[i];
            else
                ans2 ^= nums[i];
        }
        return new int[]{ans1, ans2};
    }
```

### LC..2652. 倍数求和 -2023-10-17

```java
	// lc.2652. 倍数求和
    // 很容易想到O(n) 遍历的算法
    // 对于[1, n] 区间内的数 能被x整除的数有 C = [n/x] (Gauss) 个
    // 等差数列求和得到 C * (C + 1) * x / 2
    // {A} or {B} or {C} = {A} + {B} + {C} - {AB} - {AC} - {BC} + {ABC}
    public int sumOfMultiples(int n) {
        return sum(n,3) + sum(n,5) + sum(n, 7) - sum(n, 3 * 5) - sum(n, 3 * 7) -sum(n,5 * 7) + sum(n, 3 * 5 * 7);
    }

    public int sum(int n, int x){
        return (n / x + 1) * (n / x) * x / 2;
    }
```

### LC.2530. 执行 K 次操作后的最大分数 -2023-10-18

```java
	// lc.2530. 执行 K 次操作后的最大分数
    // TopK 但是元素会有新元素添加 更新堆元素即可
    // 优化点: ceil(x / 3) -> (x + 2) / 3 避免浮点数运算
    // simple proof(Not rigorous):
    // ceil(A/B) <=> (int)((A + B - 1) / B)
    // A = k * B + C
    // A / B = K + C / B  in math
    // (int) ((A + B -1) / B) = K + (int)((C + B - 1) / B)
    // ceil(A/B) = K if C == 0
    //           = K + 1 if C >= 1
    // (int) ((A + B -1) / B)  = K if C == 0
    //                         = K + 1 if C >= 1
    // (int) ((A + B -1) / B) <=> ceil(A/B)
    public long maxKelements(int[] nums, int k) {
        PriorityQueue<Integer> heap = new PriorityQueue<>((x,y)->y-x);
        int n = nums.length;
        long ans = 0;
        for (int i = 0; i < n; i++) {
            heap.offer(nums[i]);
        }
        while (k > 0){
            int maxValue = heap.poll();
            ans += maxValue;
            heap.offer((maxValue + 2) / 3 );
            k--;
        }
        return ans;
    }
```

### LC..1726. 同积元组 -2023-10-19

```java
	// lc.1726. 同积元组
    // 第一感觉 排序 最后发现好像不需要
    // 由于 nums[i] >= 1 且互不相同 可以获得两两组合的乘积
    // 然后累计每个乘积对应的基数 C2n   可以确定 (a, b) (c, d) 不存在重复子元素
    // 由于 num[i] <= 10^4 故乘积不会溢出
    // 由于是组成(a,b,c,d)的元组  两组数选择位置有2种情况 各自组内位置 2 * 2种
    // 故结果为 C2n * 2 * 2 * 2 = n * (n - 1) * 4;
    public int tupleSameProduct(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int n = nums.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int mul = nums[i] * nums[j];
                int base = map.getOrDefault(mul, 0);
                map.put(mul, base + 1);
            }
        }
        for (Integer v: map.values()){
            ans += v * (v-1);
        }
        return ans * 4;
    }
```

### LC.2525. 根据规则将箱子分类 -2023-10-20

```java
	// lc.2525. 根据规则将箱子分类
    // 引入一个常数空间数组 减少判断
    public String categorizeBox(int length, int width, int height, int mass) {
        String[] kind = new String[]{"Neither", "Bulky", "Heavy", "Both"};
        int hFlag = 0;
        int bFlag = 0;
        if (mass >= 100)
            hFlag = 2;
        if (length >= 10000 || width >= 10000 || height >= 10000 || (long)length * width * height >= 1e9)
            bFlag = 1;
        return kind[hFlag + bFlag];
    }
```

### LC.2316. 统计无向图中无法互相到达点对数 -2023-10-21

```java
	// lc.2316. 统计无向图中无法互相到达点对数
    // 一眼并查集
    // 并查集中记录各个联通分量对应的节点数大小
    // 遍历每个节点获得其可达的节点数 -> 计算不可达节点
    // 此处使用深搜来获得联通分量的大小2942
    boolean[] visited;
    public long countPairs(int n, int[][] edges) {
        visited = new boolean[n];
        ArrayList<Integer>[] edgeMap = new ArrayList[n];
        for (int i = 0; i < n; i++)
            edgeMap[i] = new ArrayList<>();
        int m = edges.length;
        for (int i = 0; i < m; i++){
            int v1 = edges[i][0];
            int v2 = edges[i][1];
            edgeMap[v1].add(v2);
            edgeMap[v2].add(v1);
        }

        long ans = 0;
        for (int i = 0; i < n; i++) {
            if (!visited[i]){
                int num = dfs(i, edgeMap);
                ans += (long)num * (n - num);
            }
        }
        return ans >> 1;
    }

    public int dfs(int vertex, ArrayList<Integer>[] edgeMap){
        int visNum = 1;
        visited[vertex] = true;
        int size = edgeMap[vertex].size();
        for (int i = 0; i < size; i++) {
            int v = edgeMap[vertex].get(i);
            if (!visited[v])
                visNum += dfs(v, edgeMap);
        }
        return visNum;
    }
```

### LC.1402. 做菜顺序 -2023-10-22

```java
	// lc.1402. 做菜顺序
    // 第一想法动态规划 
    // 由于对于结果顺序不限定 那么很容易想到要先对输入数据进行排序
    // dp[i][j] 表示前i个数 选择其中j个数的最大值
    // dp[i][j-1] + j * sat[i-1] | dp[i-1][j-1] + j * sat[i-1]
    // 那么就要考虑是否选择sat[i-1]
    // 若不考虑那就是dp[i-1][j] 但要考虑定义是否成立

    // 很自然的想法就是让数的权重与其数值排名同步
    // 就转化为找到ai ... an 的ai
    // 可以看到ai给这个数值总和带来的收益就是 ai本身 和 之后的每一个数之和
    // 只要这个数值和大于 0 及可将其加入已选数字序列
    public int maxSatisfaction(int[] satisfaction) {
        int n = satisfaction.length;
        Arrays.sort(satisfaction);
        int ans = 0;
        int sum = 0;
        for (int i = n - 1; i >= 0 ; i--) {
            if (satisfaction[i] + sum > 0){
                sum += satisfaction[i];
                ans += sum;
            }
            else
                break;
        }
        return ans;
        // 动态规划
//        int n = satisfaction.length;
//        Arrays.sort(satisfaction);
//        int[][] dp = new int[n+1][n+1];
//        int ans = 0;
//        for (int i = 1; i <= n ; i++) {
//            for (int j = 1; j <= n; j++) {
//                dp[i][j] = dp[i-1][j-1] + j * satisfaction[i-1];
//                if (j < i){
//                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j]);
//                }
//                ans = Math.max(ans, dp[i][j]);
//            }
//        }
//        return ans;
    }
```

### LC.2678. 老人的数目 -2023-10-23

```java
	// lc.2678. 老人的数目
    // 取数比较 可以直接 substring + parseInt 或 逻辑组合
    public int countSeniors(String[] details) {
        int n = details.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            String info = details[i];
            int age = (info.charAt(11) - '0') * 10 + (info.charAt(12) - '0');
            if (age > 60)
                ans++;
        }
        return ans;
    }
```

### LC.1155. 掷骰子等于目标和的方法数 -2023-10-24

```java
	// lc.1155. 掷骰子等于目标和的方法数
    // n个骰子 每个1-k sum == target
    // dp[i][j] 表示由i个骰子sum=j的方法数
    // dp[i][j] = Σ dp[i-1][j-m]  m - [1,k]
    // dp[1][1-6] = 1 可视为由dp[0][0] 再掷一个骰子得到 故需要定义dp[0][0] 为 1
    // 其余dp[][0] 均为0
    int MOD = 1000000007;
    public int numRollsToTarget(int n, int k, int target) {
        // 空间优化
        int[] dp = new int[target+1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = target; j >= 0; j--) { // 需要重置dp[0] 为  0  不然使得dp[0]会一直加入结果 但实际上dp[i][0] = 0
                // 注意dp[j]的值被修改了 需要重置dp[j]的值
                dp[j] = 0;
                for (int l = 1; l <= k; l++) {
                    if (j >= l){
                        dp[j] = (dp[j] + dp[j-l]) % MOD;
                    }
                }
            }
        }
        return dp[target];


//        int[][] dp = new int[n+1][target+1];
//        dp[0][0] = 1;
//        for (int i = 1; i <= n; i++) {
//            for (int j = 1; j <= target; j++) {
//                for (int l = 1; l <= k; l++) {
//                    if (j >= l){      // 此处不能去掉等于的情况 由于dp[0][0] 是认为定义为1的 在计算过程中会
//                        dp[i][j] = (dp[i][j] + dp[i-1][j-l]) % MOD;
//                    }
//                }
//            }
//        }
//        return dp[n][target];
    }
```

### LC.2698. 求一个整数的惩罚数 -2023-10-25

```java
 	// lc.2698. 求一个整数的惩罚数
    // 没想到什么好办法 就只能 遍历数字 然后dfs
    // 数学优化
    // 对于一个正数 num = Σ ai * 10^i
    // num = Σ ai * (10^i - 1 + 1) = Σ ai * (10^i - 1) + ai = Σ ai + Σ ai * (10^i - 1)
    // num mod 9 = Σ ai mod 9 + Σ ai * (10^i - 1) mod 9
    // num mod 9 = Σ ai mod 9
    // 即对于一个正数 其模9的结果与其各位之和相等
    // 本题的惩罚数 要求 sum(i*i的划分) == i
    // 对于i*i的任意划分 均存在num mod 9 = Σ ai mod 9
    // sum(i*i的划分) mod 9 == sum(numBit(i)) mod 9
    // 即 i mod 9 == sum(numBit(i)) mod 9
    // 若是惩罚数则 i * i mod 9 == sum(i*i的划分) mod 9 == sum(numBit(i)) mod 9 == i mod 9
    // 即 i * i mod 9 == i mod 9
    // 可以得到i * (i-1) mod 9 == 0
    // i mod 9 == 0 || (i - 1) mod 9 == 0
    // 我们可以得到 是惩罚数的必要条件是 i mod 9 == 0 || i mod 9 == 1
    public static int punishmentNumber(int n) {
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            // 剪枝
            if (i % 9 != 0 && i % 9 != 1)
                continue;
            int square = i * i;
            String s = String.valueOf(square);
            if (dfs(s,0, i))
                ans += square;
        }
        return ans;
    }

    public static boolean dfs(String num, int index,int target){
        if (index == num.length())
            return target == 0;
        if (target > Integer.parseInt(num))
            return false;
        int sum = 0;
        for (int i = index; i < num.length(); i++) {
            sum = sum * 10 + (num.charAt(i) - '0');
            if (sum > target)
                break;
            if (dfs(num,i + 1, target - sum))
                return true;
        }
        return false;
    }
```

### LC.2520. 统计能整除数字的位数 -2023-10-26

```java
	// lc.2520. 统计能整除数字的位数
    // 正常模拟遍历每一位数
    public int countDigits(int num) {
        int temp = num;
        int ans = 0;
        while (temp > 0){
            int reminder = temp % 10;
            if (num % reminder == 0)
                ans++;
            temp /= 10;
        }
        return ans;
    }
```

### LC.1465. 切割后面积最大的蛋糕 -2023-10-27

```java
	// lc.1465. 切割后面积最大的蛋糕
    // 每个切割后蛋糕的面积为 (x2 - x1) * (y2 - y1)
    // 很显然可以通过遍历每个蛋糕的面积 然后得到最大值
    // 但实际上在分割的过程中 水平方向和竖直方向 是不影响各自方向的最值的
    // eg. 设水平方向分割为 l1 - ln 其中lk为最大段
    // 在进行竖直方向的分割时 相当于对l1-ln进行相同比例的划分
    // 记竖直分割段为 c1-cm 设竖直最大分割段为 cf
    // 对于任意竖直分割段 cj 蛋糕的面积 li * cj <= lk * cj
    // 根据轮换对称性可以得到水平方向相似的结论 cj * lk <= lk * cf
    // 即对于任意 li * cj <= lk * cf 本题即变成寻找最大的水平和竖直分割段
    // 将水平和竖直的端点分别排序 然后得到最大长度
    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {
        int MOD = 1000000007;
        Arrays.sort(horizontalCuts);
        Arrays.sort(verticalCuts);
        return (int)((long)maxSpan(horizontalCuts, h) * maxSpan(verticalCuts, w) % MOD);
    }

    public int maxSpan(int[] vertex, int end){
        int pre = 0;
        int ans = 0;
        int n = vertex.length;
        for (int i = 0; i < n; i++){
            ans = Math.max(vertex[i] - pre, ans);
            pre = vertex[i];
        }
        return Math.max(ans, end - pre);
    }
```

### LC.2558. 从数量最多的堆取走礼物 -2023-10-28

```java
	// lc.2558. 从数量最多的堆取走礼物
    // 很显然使用最大堆来取最值
    // 计算差值避免最后的一次循环统计
    // 对于 maxValue == 1 的情况进行剪枝
    public long pickGifts(int[] gifts, int k) {
        PriorityQueue<Integer> heap = new PriorityQueue<>((x,y)->y-x);
        int n = gifts.length;
        long sum = 0;
        for (int i = 0; i < n; i++) {
            heap.offer(gifts[i]);
            sum += gifts[i];
        }
        for (int i = 0; i < k; i++) {
            int maxValue = heap.poll();
            if (maxValue == 1)
                return sum;
            int left = (int) Math.sqrt(maxValue);
            sum -= maxValue - left;
            heap.offer(left);
        }
        return sum;
    }
```

### LC.274. H 指数 -2023-10-29

```java
	// lc.274. H 指数
    // 很简单的想法 排序 然后逐项比较
    // 时间优化: 改快排为计数排序
    public int hIndex(int[] citations) {
        int n = citations.length;
        int ans = 0;
        int[] counter = new int[n+1];
        for (int i = 0; i < n; i++) {
            if (citations[i] >= n){
                counter[n]++;
            }else {
                counter[citations[i]]++;
            }
        }
        for (int i = n; i >= 0; i--) {
            ans += counter[i];
            if (ans >= i)
                return i;
        }
        return ans;
        
        // version 1.1
//        int idx = citations.length - 1;
//        Arrays.sort(citations);
//        int ans = 0;
//        while (idx >= 0 && citations[idx] > ans){
//            ans++;
//            idx--;
//        }
//        return ans;

        // version 1.0
//        int n = citations.length;
//        Arrays.sort(citations);
//        int ans = 0;
//        for (int i = 0; i < n; i++)
//            ans = Math.max(Math.min(n-i, citations[i]), ans);
//        return ans;
    }
```

### LC.275. H 指数 II -2023-10-30

```java
    // lc.275. H 指数 II
    // 升序排列 + O(log n)
    // 相当于找到 满足 最大的i citations[i] >= n - i
    // 设 left 左侧均满足上述条件 来作为循环不变量 right 右侧均为不满足上述条件
    // 故循环中止条件为 left > right
    // 注意分割条件的选取 由于中点的偏左性质 最好不要使用 left = mid 使得left的位置满足条件
    // 有可能会使得 mid = left 从而无法跳出循环
    public static int hIndex(int[] citations) {
        int n = citations.length;
        int left = 0, right = n - 1;
        while (left <= right){
            int mid = (right - left) / 2 + left;
            if (citations[mid] < n - mid){
                left = mid + 1;
            }else
                right = mid - 1;
        }
        return n - left;
    }
```

### LC.2003. 每棵子树内缺失的最小基因值 -2023-10-31

```java
    // lc.2003. 每棵子树内缺失的最小基因值
    // 由于 nums 各不相同
    // 那么至多存在一个节点的gene值为1
    // 对于子树不包含gene=1的节点 其ans = 1
    // 对于包含子树gene=1的节点
    // 需要对这条从 gene=1节点 至 根节点的路径上的所有点进行更新
    // 对于一个节点 a setG(a) = Σ setG(直接子节点) + gene(a)
    // 同时可以确定 ans[i] >= ans[son(i)] son(i) 为i在路径上的子节点
    // 对于每个路径上的点进行更新
    public int[] smallestMissingValueSubtree(int[] parents, int[] nums) {
        int n = parents.length;
        List<Integer>[] children = new List[n];
        for (int i = 0; i < n; i++)
            children[i] = new ArrayList<Integer>();
        for (int i = 1; i < n; i++)
            children[parents[i]].add(i);

        Set<Integer> geneSet = new HashSet<Integer>();
        boolean[] visited = new boolean[n];

        int[] ans = new int[n];
        Arrays.fill(ans, 1);
        int base = 1, pathNode = -1;
        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) {
                pathNode = i;
                break;
            }
        }
        while (pathNode != -1) {
            dfs(pathNode, nums, children, geneSet, visited);
            while (geneSet.contains(base))
                base++;
            ans[pathNode] = base;
            pathNode = parents[pathNode];
        }
        return ans;
    }

    public void dfs(int node, int[] nums, List<Integer>[] children, Set<Integer> geneSet, boolean[] visited) {
        if (visited[node])
            return;
        visited[node] = true;
        for (int child : children[node]) {
            dfs(child, nums, children, geneSet, visited);
        }
        geneSet.add(nums[node]);
    }



    public static void main(String[] args) {
        hIndex2(new int[]{1,2,100});
    }
```

### LC.2127. 参加会议的最多员工数 -2023-11-01

```java
    // lc.2127. 参加会议的最多员工数
    // 拓扑排序实用于DAG 若包含环 则会导致环结构无法访问
    // n个人 n条边 必然有环
    // 对于环来说 环上的成员必然能够组成一桌
    // 节点数大于2的环无法继续添加其他成员 而两个节点的环是可以继续延伸节点的
    // n -> x <-> y <- m 类似这种结构 且 多个这种结构是能够共存的
    // 故答案就是 最大的环 与 多个该结构 中节点数更大者
    public int maximumInvitations(int[] favorite) {
        int n = favorite.length;
        int[] inD = new int[n];
        for (int i = 0; i < n; ++i)
            inD[favorite[i]]++;
        int[] f = new int[n];
        Arrays.fill(f, 1);
        Queue<Integer> queue = new ArrayDeque<Integer>();
        for (int i = 0; i < n; ++i)
            if (inD[i] == 0)
                queue.offer(i);
        while (!queue.isEmpty()) {
            int v1 = queue.poll();
            int v2 = favorite[v1];
            f[v2] = Math.max(f[v2], f[v1] + 1);
            inD[v2]--;
            if (inD[v2] == 0)
                queue.offer(v2);
        }
        int maxRing = 0, listLen = 0;
        for (int i = 0; i < n; ++i) {
            if (inD[i] != 0) {
                int j = favorite[i];
                if (favorite[j] == i) {
                    listLen += f[i] + f[j];
                    inD[i] = 0;
                    inD[j] = 0;
                }
                else {
                    int vertex = i, count = 1;
                    while (true) {
                        vertex = favorite[vertex];
                        inD[vertex] = 0;
                        if (vertex == i)
                            break;
                        count++;
                    }
                    maxRing = Math.max(maxRing, count);
                }
            }
        }
        return Math.max(maxRing, listLen);
    }
```

### LC.2103. 环和杆 -2023-11-02

```java
    // lc.2103. 环和杆
    // 记录每个竿的包含的颜色种类
    // 为了统计种类计算 故仅记录颜色是否存在 通过 & 得到种类结果
    // 更进一步 由于只有RGB三种颜色 可以将颜色的存在信息压缩
    // 设定 R 1 G 2 B 4 类似文件权限判断
    // colors = 7 即表示有三种颜色
    public int countPoints(String rings) {
        int n = rings.length();
        int poleNum = 10;
        int[] colors = new int[poleNum];
        HashMap<Character, Integer> map = new HashMap<>();
        map.put('R', 1);
        map.put('G', 2);
        map.put('B', 4);
        for (int i = 0; i < n; i+=2) {
            int color = map.get(rings.charAt(i));
            int location = rings.charAt(i + 1) - '0';
            colors[location] |= color;
        }
        int ans = 0;
        for (int i = 0; i < poleNum; i++)
            ans += colors[i] == 7? 1: 0;
        return ans;
    }
```

### LC.117. 填充每个节点的下一个右侧节点指针 II -2023-11-03

```java
    // lc.117. 填充每个节点的下一个右侧节点指针 II
    // 简单的层序遍历
    // 空间优化版: 在当前层完成下一层顺序的构建
    // lowerHead 是一个指向下一层第一个节点的头节点
    // 通过tmp使得lower层节点连接在一起
    public Node connect(Node root) {
        Node lowerHead = new Node();
        Node cur = root;
        // 当cur = null 意味着遍历完全部节点
        while (cur != null){
            lowerHead.next = null;
            Node tmp = lowerHead;
            while (cur != null){
                if (cur.left != null){
                    tmp.next = cur.left;
                    tmp = tmp.next;
                }
                if (cur.right != null){
                    tmp.next = cur.right;
                    tmp = tmp.next;
                }
                cur = cur.next;
            }
            // cur = null 意味着已经遍历完当前行
            cur = lowerHead.next;
        }
        return root;

        // v1.1
//        Deque<Node> queue = new ArrayDeque<>();
//        if (root == null)
//            return null;
//        queue.offer(root);
//        while (!queue.isEmpty()){
//            int size = queue.size();
//            for (int i = 1; i <= size; i++) {
//                Node node = queue.poll();
//                if (node.left != null)
//                    queue.offer(node.left);
//                if (node.right != null)
//                    queue.offer(node.right);
//                if (i == size)
//                    node.next = null;
//                else
//                    node.next = queue.peek();
//            }
//        }
//        return root;
    }
```

###  LC.421. 数组中两个数的最大异或值 -2023-11-04

```java
    // lc.421. 数组中两个数的最大异或值
    // 直接的想法 双循环遍历
    // 两个数的最大异或值 肯定需要尽可能高位为 1 且 两个数的二进制位尽可能不相同
    // ans = num1 ^ num2 <=> num1 = ans ^ num2
    // 可以通过预设ans的结果来遍历nums 判断是否存在这样的数对即可获得最终的ans
    public int findMaximumXOR(int[] nums) {
        int ans = 0;
        for (int k = 30; k >= 0; k--) {
            HashSet<Integer> set = new HashSet<>();
            ans = ans * 2 + 1;
            for (int num : nums)
                set.add(num >> k);
            boolean exist = false;
            for (int num : nums){
                if (set.contains(num >> k ^ ans)){
                    exist = true;
                    break;
                }
            }
            if (!exist)
                ans = ans - 1;
        }
        return ans;
    }
```

### LC.187. 重复的DNA序列 -2023-11-05

```java
    // lc.187. 重复的DNA序列
    // 寻找长度为10的重复串
    // hashmap来存储访问过的字符串
    // 进行状态压缩 4种状态 + 10个字符 可以使用int来存储
    public List<String> findRepeatedDnaSequences(String s) {
        int n = s.length();
        int len = 10;
        List<String> ans = new ArrayList<>();
        if (n <= len)
            return ans;
        HashMap<Character, Integer> numMap = new HashMap<>();
        numMap.put('A', 0);
        numMap.put('C', 1);
        numMap.put('G', 2);
        numMap.put('T', 3);
        int pre = 0;
        int mask = 1;
        for (int i = 0; i < len; i++) {
            pre = pre << 2 | numMap.get(s.charAt(i));
            mask = mask << 2;
        }
        mask--;
        HashMap<Integer,Integer> map = new HashMap<>();
        map.put(pre, 1);
        for (int i = len; i < n; i++) {
            int cur = ((pre << 2) | numMap.get(s.charAt(i))) & mask;
            int count = map.getOrDefault(cur, 0);
            if (count == 1)
                ans.add(s.substring(i-len + 1, i + 1));
            map.put(cur, count + 1);
            pre = cur;
        }
        return ans;
    }

```

### LC.318. 最大单词长度乘积 -2023-11-06

```java
    // lc.318. 最大单词长度乘积
    // 由于只在乎是否存在共同的字符 故对每个单词进行状态压缩
    // & = 0 即可判断是否有共同字符
    public int maxProduct(String[] words) {
        // m2 数据结构高效一点
        int n = words.length;
        int[] masks = new int[n];
        for (int i = 0; i < n; i++) {
            int length = words[i].length();
            int mask = 0;
            for (int j = 0; j < length; j++) {
                mask |= (1 << words[i].charAt(j) - 'a');
            }
            masks[i] = mask;
        }
        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if((masks[i] & masks[j]) == 0)
                    ans = Math.max(ans,words[i].length() * words[j].length());
            }
        }
        return ans;
        // m1 对于含有相同字符组成的字符串表示进行压缩
//        HashMap<Integer,Integer> map = new HashMap<>();
//        int n = words.length;
//        for (int i = 0; i < n; i++) {
//            String str = words[i];
//            int len = str.length();
//            int mask = 0;
//            for (int j = 0; j < len; j++)
//                mask |= 1 << (str.charAt(j) - 'a');
//            map.put(mask, Math.max(map.getOrDefault(mask, 0), len));
//        }
//        Set<Integer> mSet = map.keySet();
//        int ans = 0;
//        for (int m1: mSet) {
//            for(int m2: mSet){
//                if ((m1 & m2) == 0)
//                    ans = Math.max(ans, map.get(m1) * map.get(m2));
//            }
//        }
//        return ans;
    }
```

### LC.2586. 统计范围内的元音字符串数 -2023-11-07

```java
    // lc.2586. 统计范围内的元音字符串数
    // 直接遍历
    public int vowelStrings(String[] words, int left, int right) {
        int ans = 0;
        for (; left <= right; left++) {
            String s = words[left];
            int end = s.length() - 1;
            if (isVowel(s.charAt(0)) && isVowel(s.charAt(end)))
                ans++;
        }
        return ans;
    }

    public boolean isVowel(char ch){
        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch =='u';
    }
```

### LC.2609. 最长平衡子字符串 -2023-11-08

```java
    // lc.2609. 最长平衡子字符串
    // 要求 0 1 都是连续段 且 数量相等
    // 直接遍历统计
    public int findTheLongestBalancedSubstring(String s) {
        int n = s.length();
        int countZ = 0;
        int countO = 0;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '1'){
                countO++;
                ans = Math.max(ans, Math.min(countZ,countO) * 2);
            }else if (i == 0 || s.charAt(i - 1) == '1'){
                countZ = 1;
                countO = 0;
            }else {
                countZ++;
            }
        }
        return ans;
    }
```

### LC.2258. 逃离火灾 -2023-11-09

```java
    // lc.2258. 逃离火灾
    // 0草 1火 2墙
    // 可能与安全屋的最短路径有关
    // distM[i][j] 表示 人到 grid[i][j]的最短距离
    // distF[i][j] 表示 火到 grid[i][j]的最短距离
    // 若 distM[i][j] < distF[i][j] 说明火不会烧到人
    // proof: 若 途中ik,jk被烧到了 distM[i][j] >= distF[i][j]
    // 那么按照同样的路径从 ik,jk -> i,j distM[i][j] >= distF[i][j]
    // 矛盾 故火不会在途中烧到人
    // 那么首选需要计算出人到安全屋的最短距离 再计算火到安全屋的最短距离
    // 由于可能有多个着火点 避免重复计算 故采用多点bfs
    // 本题由于和火同时到达安全屋算成功 需要考虑一些特殊情况
    // 若同时到达安全屋 则可能存在同时到达安全屋相邻点的情况
    // TODO
    int[][] DIRS = new int[][]{{1,0}, {0,-1}, {-1,0}, {0,1}};
    public int maximumMinutes(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int ans = 0;
        ArrayDeque<int[]> deque = new ArrayDeque<>();
        deque.add(new int[]{0,0});
        int[] distM = bfs(grid, deque, m, n);
        if (distM[0] < 0)
            return -1;
        deque.clear();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1)
                    deque.offer(new int[]{i, j});
            }
        }
        int[] distF = bfs(grid, deque, m, n);
        if (distF[0] < 0)
            return 1000000000;
        int diff = distF[0] - distM[0];
        if (diff < 0)
            return -1;
        if (distM[1] != -1 && distF[1] - distM[1] > diff
        ||  distM[2] != -1 && distF[2] - distM[2] > diff)
            return diff;
        return diff - 1;
    }

    public int[] bfs(int[][] grid, Deque<int[]> nodes, int m, int n){
        int[][] dist = new int[m][n];
        for(int[] dis: dist)
            Arrays.fill(dis, -1);
        for(int[] node: nodes)
            dist[node[0]][node[1]] = 0;
        for (int i = 1; !nodes.isEmpty(); i++) {
            int size = nodes.size();
            for (int j = 0; j < size; j++) {
                int[] node = nodes.poll();
                for(int[] dir: DIRS){
                    int x = node[0] + dir[0];
                    int y = node[1] + dir[1];
                    if (x >= 0 && x < m && y >= 0 && y < n && dist[x][y] == -1 && grid[x][y] == 0){
                        dist[x][y] = i;
                        nodes.add(new int[]{x,y});
                    }
                }
            }
        }
        return new int[]{dist[m-1][n-1], dist[m-2][n-1], dist[m-1][n-2]};
    }
```

### LC.2300. 咒语和药水的成功对数 -2023-11-10

```java
    // lc.2300. 咒语和药水的成功对数
    // 第一想法 排序 + 二分
    // 还可以创建spells的索引数组排序 充分利用单调性
    // 空间换时间还可以使用前缀和
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        // 空间换时间 前缀和
        int n = spells.length;
        int m = potions.length;
        int[] ans = new int[n];
        int max = 0;
        for (int i = 0; i < n; i++)
            max = Math.max(max, spells[i]);

        int[] count = new int[max + 1];
        int minPotion = (int) ((success - 1) / max);

        for (int p: potions){
            if (p > minPotion){
                count[(int)((success + p - 1) / p)]++;
            }
        }

        for (int i = 1; i <= max; i++)
            count[i] += count[i-1];

        for (int i = 0; i < n; i++) {
            ans[i] = count[spells[i]];
        }

        return ans;
        // 二分
//        int n = spells.length;
//        int m = potions.length;
//        int[] ans = new int[n];
//        Arrays.sort(potions);
//        for (int i = 0; i < n; i++) {
//            int v1 = spells[i];
//            long target = (success + v1 - 1) / v1;
//            ans[i] = binarySearch(potions, target);
//        }
//        return ans;
        // 单调性
//        int n = spells.length;
//        int m = potions.length;
//        int[] ans = new int[n];
//        Arrays.sort(potions);
//        int[][] idx = new int[n][2];
//        for (int i = 0; i < n; i++) {
//            idx[i][0] = spells[i];
//            idx[i][1] = i;
//        }
//        Arrays.sort(idx, (a,b) -> a[0] - b[0]);
//        for (int i = 0, j = m - 1; i < n; i++) {
//            int num = idx[i][0];
//            int index = idx[i][1];
//            while (j >= 0 && (long) potions[j] * num >= success)
//                j--;
//            ans[index] = m - 1 - j;
//        }
//        return ans;
    }

    // 返回大于等于 target 的元素个数
    public int binarySearch(int[] nums, long target){
        int left = 0;
        int right = nums.length -1;
        while (left <= right){
            int mid = (right - left) / 2 + left;
            if (nums[mid] >= target){
                right = mid - 1;
            }else
                left = mid + 1;
        }
        return nums.length - 1 - right;
    }
```

### LC.765. 情侣牵手 -2023-11-11

```java
    // lc.765. 情侣牵手
    // 对于两队情侣 如果做错了位置 那么需要交换一次
    // 对于由n对做错位置的情侣构成的集合(该集合是能在集合内部交换后得到正确位置的最小集合)
    // 交换一次就可以确保产生一对正确的情侣
    // 此时集合大小由 n 变为n-1 直到集合大小变为1  交换次数为n - 1
    // 故需要找到row中有多少个这样的集合 进行求和即可
    // 设有k个集合 共N对 每个集合含有ni对 交换次数 Σ (ni - 1) = N - k
    public int minSwapsCouples(int[] row) {
        int n = row.length;
        int N = n >> 1;
        UnionFind uf = new UnionFind(N);
        for (int i = 0; i < n; i += 2) {
            uf.union(row[i] >> 1,row[i+1] >> 1);
        }
        return N - uf.getCount();
    }

    class UnionFind{
        private int[] parent;
        private int count;

        public UnionFind(int n){
            this.parent = new int[n];
            this.count = n;
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }

        public int find(int x){
            while (x != parent[x]){
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }

        public void union(int x, int y){
            int rootX = find(x);
            int rootY = find(y);
            if (rootX != rootY){
                parent[rootY] = rootX;
                count--;
            }
        }

        public int getCount() {
            return count;
        }
    }
```

### LC.715. Range 模块 -2023-11-12

```java
    // lc.715. Range 模块
    // 注意边界条件
    class RangeModule {

        TreeMap<Integer, Integer> intervals;

        public RangeModule() {
            intervals = new TreeMap<Integer, Integer>();
        }

        public void addRange(int left, int right) {
            Map.Entry<Integer, Integer> entry = intervals.higherEntry(left);
            if (entry != intervals.firstEntry()) {
                Map.Entry<Integer, Integer> start = entry != null ? intervals.lowerEntry(entry.getKey()) : intervals.lastEntry();
                if (start != null && start.getValue() >= right) {
                    return;
                }
                if (start != null && start.getValue() >= left) {
                    left = start.getKey();
                    intervals.remove(start.getKey());
                }
            }
            while (entry != null && entry.getKey() <= right) {
                right = Math.max(right, entry.getValue());
                intervals.remove(entry.getKey());
                entry = intervals.higherEntry(entry.getKey());
            }
            intervals.put(left, right);
        }

        public boolean queryRange(int left, int right) {
            Map.Entry<Integer, Integer> entry = intervals.higherEntry(left);
            if (entry == intervals.firstEntry()) {
                return false;
            }
            entry = entry != null ? intervals.lowerEntry(entry.getKey()) : intervals.lastEntry();
            return entry != null && right <= entry.getValue();
        }

        public void removeRange(int left, int right) {
            Map.Entry<Integer, Integer> entry = intervals.higherEntry(left);
            if (entry != intervals.firstEntry()) {
                Map.Entry<Integer, Integer> start = entry != null ? intervals.lowerEntry(entry.getKey()) : intervals.lastEntry();
                if (start != null && start.getValue() >= right) {
                    int ri = start.getValue();
                    if (start.getKey() == left) {
                        intervals.remove(start.getKey());
                    } else {
                        intervals.put(start.getKey(), left);
                    }
                    if (right != ri) {
                        intervals.put(right, ri);
                    }
                    return;
                } else if (start != null && start.getValue() > left) {
                    if (start.getKey() == left) {
                        intervals.remove(start.getKey());
                    } else {
                        intervals.put(start.getKey(), left);
                    }
                }
            }
            while (entry != null && entry.getKey() < right) {
                if (entry.getValue() <= right) {
                    intervals.remove(entry.getKey());
                    entry = intervals.higherEntry(entry.getKey());
                } else {
                    intervals.put(right, entry.getValue());
                    intervals.remove(entry.getKey());
                    break;
                }
            }
        }
    }
```

### LC.307. 区域和检索 - 数组可修改 -2023-11-13

```java
    // lc.307. 区域和检索 - 数组可修改
    // 前缀和肯定能做
    // 线段树4N空间
    // node 表示对于节点下标 s - e 是node对于的区间范围 [s,e]
    class NumArray {

        private int[] segmentTree;
        private int n;

        public NumArray(int[] nums) {
            n = nums.length;
            segmentTree = new int[nums.length * 4];
            build(0, 0, n - 1, nums);
        }

        public void update(int index, int val) {
            change(index, val, 0, 0, n - 1);
        }

        public int sumRange(int left, int right) {
            return range(left, right, 0, 0, n - 1);
        }

        private void build(int node, int s, int e, int[] nums) {
            if (s == e) {
                segmentTree[node] = nums[s];
                return;
            }
            int m = s + (e - s) / 2;
            build(node * 2 + 1, s, m, nums);
            build(node * 2 + 2, m + 1, e, nums);
            segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];
        }

        private void change(int index, int val, int node, int s, int e) {
            if (s == e) {
                segmentTree[node] = val;
                return;
            }
            int m = s + (e - s) / 2;
            if (index <= m) {
                change(index, val, node * 2 + 1, s, m);
            } else {
                change(index, val, node * 2 + 2, m + 1, e);
            }
            segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];
        }

        private int range(int left, int right, int node, int s, int e) {
            if (left == s && right == e) {
                return segmentTree[node];
            }
            int m = s + (e - s) / 2;
            if (right <= m) {
                return range(left, right, node * 2 + 1, s, m);
            } else if (left > m) {
                return range(left, right, node * 2 + 2, m + 1, e);
            } else {
                return range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m + 1, e);
            }
        }
    }
```

###  LC.1334. 阈值距离内邻居最少的城市 -2023-11-14

```java
    // 1334. 阈值距离内邻居最少的城市
    // 计算每个节点间的最小距离 并统计比大小即可
    // Floyd or Dijkstra
    // 注意计算的是到其他城市的距离 故可以不计算自环距离 或 不统计自环
    public int findTheCity(int n, int[][] edges, int distanceThreshold) {
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], 10001);
        }
        for (int[] edge: edges)
            dist[edge[0]][edge[1]] = dist[edge[1]][edge[0]] = edge[2];
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
//                    if (i == j)
//                        continue;
                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
        int ans = 0;
        int minCount = n;
        for (int i = 0; i < n; i++) {
            int count = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && dist[i][j] <= distanceThreshold)
                    count++;
            }
            if (count <= minCount){
                ans = i;
                minCount = count;
            }
        }
        return ans;
    }
```

### LC.2656. K 个元素的最大和 -2023-11-15

```java
    // lc.2656. K 个元素的最大和
    // 每次取最大值max 而 重新添加的值为max+1 显然同样为更新后的最大值
    // 故k次取数实际上就是取 max 到 max + k - 1；
    // 等差数列求和即可
    public int maximizeSum(int[] nums, int k) {
        int n = nums.length;
        int max = nums[0];
        for (int i = 0; i < n; i++)
            max = Math.max(max, nums[i]);
        return (2 * max + k - 1) * k / 2;
    }
```

### LC.2760. 最长奇偶子数组 -2023-11-16

```java
    // lc.2760. 最长奇偶子数组
    // 设已有的符合条件的子数组为[pre,cur]
    // 若下一个位置不符条件 则[pre,cur] 任意取 pre' ans(pre) >= ans(pre')
    // 故可以每次遇到起始位置就将这个子数组遍历完毕
    public int longestAlternatingSubarray(int[] nums, int threshold) {
        int ans = 0;
        int cur = 0;
        int n = nums.length;
        while (cur < n){
            if (nums[cur] > threshold || nums[cur] % 2 != 0) {
                cur++;
                continue;
            }
            int pre = cur;
            cur++;
            while (cur < n && nums[cur] <= threshold && nums[cur] % 2 != nums[cur - 1] % 2)
                cur++;
            ans = Math.max(ans, cur - pre);
        }
        return ans;
    }
```

### LC.2736. 最大和查询 -2023-11-17

```java
    // lc.2736. 最大和查询
    // 比较简单的想法就是双重循环遍历 hard应该是过不了的
    // 那么大概率需要对数据进行排序
    // 按照某一个元素进行排序 然后处理另一个元素
    // 由于结果需要nums1 num2对应位置元素 故将其绑定
    // 进行 x 过滤 再进行 y 过滤 最后 挑选出 nums1 + nums2 的最大值
    // 按照 x 对 nums 进行排序
    // 由于过滤要求是找到大于等于的值 故遍历从大至小进行 充分利用单调性减少计算
    // 对于 qi 和 qj (i 先于 j) 那么 符合qi的nums1均符合qj
    // qj需要的就是比之前更大nums2的值 否则无法使得nums1 + nums2的值更大
    // 若 qj 的 nums1 + nums2 大于之前的值 那么之前的值是不可能作为结果的 故可以剔除
    // 若 qj 的 nums1 + nums2 大于之前的值 那么还需要考虑其 nums2的值是更大 若小于前值 则可以不考虑
    // 那么就可以维护一个单调栈 按照nums2的值单调递增 nums1 + nums2 单调递减的栈
    // 这就是对于满足x的条件下 对于 y 的可选集
    // 那么就是找到单调栈中符合 >= y 的第一个元素 对应的 nums1 + nums2
    public int[] maximumSumQueries(int[] nums1, int[] nums2, int[][] queries) {
        int n = nums1.length;
        int[][] sortedNums = new int[n][2];
        for (int i = 0; i < n; i++) {
            sortedNums[i][0] = nums1[i];
            sortedNums[i][1] = nums2[i];
        }
        Arrays.sort(sortedNums, (a, b) -> b[0] - a[0]);
        int q = queries.length;
        int[][] sortedQueries = new int[q][3];
        for (int i = 0; i < q; i++) {
            sortedQueries[i][0] = queries[i][0];
            sortedQueries[i][1] = queries[i][1];
            sortedQueries[i][2] = i;
        }
        Arrays.sort(sortedQueries, (a, b) -> b[0] - a[0]);
        List<int[]> stack = new ArrayList<int[]>();
        int[] answer = new int[q];
        Arrays.fill(answer, -1);
        int i = 0;
        for (int[] query : sortedQueries) {
            int x = query[0], y = query[1], idx = query[2];
            while (i < n && sortedNums[i][0] >= x) {
                int[] pair = sortedNums[i];
                int num1 = pair[0], num2 = pair[1];
                int sum = num1 + num2;
                while (!stack.isEmpty() && stack.get(stack.size() - 1)[1] <= sum)
                    stack.remove(stack.size() - 1);
                if (stack.isEmpty() || stack.get(stack.size() - 1)[0] < num2)
                    stack.add(new int[]{num2, sum});
                i++;
            }
            int k = binarySearch(stack, y);
            if (k < stack.size()) {
                answer[idx] = stack.get(k)[1];
            }
        }
        return answer;
    }

    public int binarySearch(List<int[]> list, int target) {
        int low = 0, high = list.size() - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (list.get(mid)[0] >= target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
```

### LC.2342. 数位和相等数对的最大和 -2023-11-18

```java
    // lc.2342. 数位和相等数对的最大和
    // 由于数据分布 [1, 1e9] 位数和最大为 9个9 此处可用数组来替代hash表
    // 由于只需要最大的两个数 故只需存储之前访问过的最大值即可
    public int maximumSum(int[] nums) {
        int ans = -1;
        int n = nums.length;
        int[] sums = new int[82];
        for (int i = 0; i < n; i++) {
            int cur = nums[i];
            int sum = 0;
            while (cur != 0){
                sum += cur % 10;
                cur /= 10;
            }
            if (sums[sum] != 0)
                ans = Math.max(ans, sums[sum] + nums[i]);
            sums[sum] = Math.max(sums[sum], nums[i]);
        }
        return ans;
    }
```

### LC.689. 三个无重叠子数组的最大和 -2023-11-19

```java
    // lc.689. 三个无重叠子数组的最大和
    // 第一想法统计每三个数之和 然后遍历选择最大的三组和 时间复杂度O(n)肯定可以拿下
    // 但空间能否进行优化 多窗口遍历 记录前几组窗口的最值
    // 由于窗口没有重叠故可以直接取上一组的最值
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int[] ans = new int[3];
        int n = nums.length;
        int sum1 = 0, maxSum1 = 0, maxSum1Index = 0;
        int sum2 = 0, maxSum12 = 0, maxSum12Index1 = 0, maxSum12Index2 = 0;
        int sum3 = 0, maxSum123 = 0;
        for (int i = k * 2; i < n; i++) {
            sum1 += nums[i - k * 2];
            sum2 += nums[i - k];
            sum3 += nums[i];
            // 到达窗口大小
            if (i >= k * 3 - 1){
                if (sum1 > maxSum1){
                    maxSum1 = sum1;
                    maxSum1Index = i - 3 * k + 1;
                }
                if (maxSum1 + sum2 > maxSum12){
                    maxSum12 = maxSum1 + sum2;
                    maxSum12Index1 = maxSum1Index;
                    maxSum12Index2 = i - 2 * k + 1;
                }
                if (maxSum12 + sum3 > maxSum123){
                    maxSum123 = maxSum12 + sum3;
                    ans[0] = maxSum12Index1;
                    ans[1] = maxSum12Index2;
                    ans[2] = i -k + 1;
                }
                sum1 -= nums[i - 3 * k + 1];
                sum2 -= nums[i - 2 * k + 1];
                sum3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
```

### LC.53. 最大子数组和 -2023-11-20

```java
    // lc.53. 最大子数组和
    // dp肯定能做
    // dp[i] 定义为 以nums[i] 结尾的数组的最大和
    // dp[i] = MAX(dp[i-1] + nums[i], nums[i]) 遍历过程中 根据dp来修改结果
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int ans = nums[0];
        int cur = nums[0];
        for (int i = 1; i < n; i++) {
            cur = Math.max(cur + nums[i], nums[i]);
            ans = Math.max(ans, cur);
        }
        return ans;
    }
```

###  LC.2216. 美化数组的最少删除数 -2023-11-21

```java
    // lc.2216. 美化数组的最少删除数
    public int minDeletion(int[] nums) {
        int remove = 0;
        int n = nums.length;
        int i = 0;
        while (i < n){
            int j = i + 1;
            while (j < n && nums[j] == nums[i]){
                remove++;
                j++;
            }
            i = j + 1;
        }
        return remove + ((n - remove) & 1);
    }
```

###  LC.2304. 网格中的最小路径代价 -2023-11-22

```java
    // lc.2304. 网格中的最小路径代价
    // 动态规划 dp[i][j] 表示到 grid[i][j]最小路径代价
    // dp[i][j] = Math.min(dp[i-1][k] + moveCost[grid[i-1][k][grid[i][j]]
    // dp的状态仅与上一行有关 故可以仅存储两行的状态信息 利用索引变化来区分当前行和上一行
    public int minPathCost(int[][] grid, int[][] moveCost) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[2][n];
        for (int i = 0; i < n; i++)
            dp[0][i] = grid[0][i];
        int pre = 0;
        for (int i = 1; i < m; i++) {
            int cur = 1 - pre;
            for (int j = 0; j <n; j++) {
                dp[cur][j] = Integer.MAX_VALUE;
                for (int k = 0; k < n; k++)
                    dp[cur][j] = Math.min(dp[cur][j], dp[pre][k] + moveCost[grid[i-1][k]][j] + grid[i][j]);
            }
            pre = cur;
        }
        int ans = dp[pre][0];
        for (int i = 0; i < n; i++) {
            ans = Math.min(ans, dp[pre][i]);
        }
        return ans;
    }
```

### LC.1410. HTML 实体解析器 -2023-11-23

```java
    // lc.1410. HTML 实体解析器
    // 模拟 每次遇到 & 处理后续字符 判断是否为实体字符
    // 在处理后续字符从循环中
    // 1. 到字符串结尾也没遇到 ';' 这种情况可以直接将这段字符串拼接
    // 2. 在长度范围内没遇到 ';'   同上
    // 3. 在长度6内遇到了; 那么这段字符串就是 & [.] ;
    //    但由于实体字符的长度不固定 特殊情况  & & ;
    // 由于我们是每次遇到 & 都需要进行处理 而在其处理过程中是有可能遇到 &
    // 解决办法:
    // 1. 增加对&的判断
    // 2. 不再直接对未匹配的字符串进行拼接 继续遍历下一个字符 而不是进行跳跃 只保留能匹配的字符串
    // 上述办法均会增加一定的冗余计算
    public String entityParser(String text) {
        int n = text.length();
        HashMap<String,String> map = new HashMap<>();
        map.put("&quot;", "\"");
        map.put("&apos;", "'");
        map.put("&amp;", "&");
        map.put("&gt;", ">");
        map.put("&lt;", "<");
        map.put("&frasl;", "/");
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            char ch = text.charAt(i);
            if (ch == '&'){
                int cur = i + 1;
                while (cur < n && cur - i < 6 && text.charAt(cur) != ';' && text.charAt(cur) != '&')
                    cur++;
                if (cur < n && text.charAt(cur) == ';'){
                    String str = text.substring(i, cur+1);
                    sb.append(map.getOrDefault(str, str));
                    i = cur;
                    continue;
                }
            }
            sb.append(ch);
        }
        return sb.toString();
    }
```

### LC.2824. 统计和小于目标的下标对数目 -2023-11-24

```java
    // lc.2824. 统计和小于目标的下标对数目
    // 最简单的想法 双循环遍历
    // 但一般O(n^2) 这种都可以通过排序+数字特征优化到O(n * log n)
    // 对于区间[i,j] 若nums[i] + nums[j] >= target 那么[i,j]区间中的数组合均不符合条件
    // nums[i] + nums[j] < target 则 nums[i] 与 [i+1,j]中的数组组合均符合条件
    // 由于要寻找 n1 + n2 < target的组合 
    // 我们需要使用尽可能小的n1来把尽可能大的n2筛选掉
    // 确保循环一致性: 所有可选结果均保留在循环中的数据集中
    // 若从大到小 会导致每次循环保留的数据较小 使得而更新后的n1存在与较大数组合符合条件的可能
    // 故n1需要从小到大遍历 较小的n1确保了上界的上界 使得每次筛选掉的数均不可能作为后续循环的可行解
    public int countPairs(List<Integer> nums, int target) {
        Collections.sort(nums);
        int ans = 0;
        int n = nums.size();
        int left = 0, right = n - 1;
        while (left < right){
            if (nums.get(left) + nums.get(right) >= target)
                right--;
            else {
                ans += right - left;
                left++;
            }
        }
        return ans;
        // 从反面计算
        // 共 n * (n - 1) / 2总组合 可以>=的组合数 得到<的组合数
//        while (left < right){
//            if (nums.get(left) + nums.get(right) < target)
//                left++;
//            else{
//                ans += right - left;
//                right--;
//            }
//        }
//        return n * (n - 1) / 2 - ans;
    }
```

### LC.1457. 二叉树中的伪回文路径 -2023-11-25

```java
    // lc.1457. 二叉树中的伪回文路径
    // 记录从根节点到叶节点中数字集合
    // 在数字集合中 出现次数为奇数的数字最多为一种 即为伪回文路径
    // 基本想法就是记录当前出现的数字及其次数 还有奇数次数字的个数以及数字本身
    // 位运算优化:
    // 由于数字只会是 1 - 9 可以利用一个整数来记录当前出现的数字集合
    // 可以利用异或运算来进行数字集合的奇数出现次数判断
    // 最后判断整数二进制数位中1的个数
    public int pseudoPalindromicPaths (TreeNode root) {
        return dfs(root, 0);
    }

    public int dfs(TreeNode node, int visited){
        if (node == null)
            return 0;
        visited ^= 1 << node.val;
        if (node.left == null && node.right == null)
            return (visited & (visited - 1)) == 0? 1: 0;
        return dfs(node.left, visited) + dfs(node.right, visited);
    }
```

### LC.828. 统计子串中的唯一字符 -2023-11-26

```java
    // lc.828. 统计子串中的唯一字符
    // 由于计算重复字符串 故可以计算每个字符对于最后子串和的贡献
    // 每个字符参与构成的子串 =  左侧字符数 * 右侧字符数
    // 该字符对子串的贡献值为 = 两侧最近出现该字符区间构成的字符串的子串数
    public int uniqueLetterString(String s) {
        HashMap<Character,List<Integer>> map = new HashMap<>();
        int n = s.length();
        char[] chars = s.toCharArray();
        for (int i = 0; i < n; i++) {
            char ch = chars[i];
            if(!map.containsKey(ch)){
                List<Integer> list = new ArrayList<>();
                map.put(ch,list);
                list.add(-1);
            }
            map.get(ch).add(i);
        }
        int ans = 0;
        for(Map.Entry<Character,List<Integer>> entry: map.entrySet()){
            List<Integer> list = entry.getValue();
            int size = list.size();
            list.add(n);
            for (int i = 1; i < size; i++) {
                ans += (list.get(i) - list.get(i-1)) * (list.get(i + 1) - list.get(i));
            }
        }
        return ans;
    }
```

### LC.907. 子数组的最小值之和 -2023-11-27

```java
    // lc.907. 子数组的最小值之和
    // 思路同上 计算每个数的贡献即可
    // 同时可以用单调栈来进行优化
    public int sumSubarrayMins(int[] arr) {
        Deque<Integer> stack = new ArrayDeque<>();
        int MOD = 1000000007;
        int n = arr.length;
        long ans = 0;
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]){
                int idx = stack.pop();
                int left = stack.isEmpty()? -1: stack.peek();
                ans += (long) (idx - left) * (i - idx) * arr[idx];
                ans %= MOD;
            }
            stack.push(i);
        }
        while (!stack.isEmpty()){
            int idx = stack.pop();
            int left = stack.isEmpty()? -1: stack.peek();
            ans += (long) (idx - left) * (n - idx) * arr[idx];
            ans %= MOD;
        }
        return (int)(ans % MOD);
    }
```

### LC.1670. 设计前中后队列 -20203-11-28

```java
    // lc.1670. 设计前中后队列
    // 1. 利用链表实现
    //    记录首节点 尾节点 以及中间节点的信息
    //    中间节点的位置根据插入位置以及节点的总个数进行移动
    // 2. 双端队列实现 直接将队列拆分为两部分 那么中间插入就是在两个队列的尾和头进行插入
    //    需要调节 front 和 back 两部分的长度从而使得中间的插入位置能够是front的尾或back的头
    //    为了避免不必要的判断 可以固定中间节点的插入位置为front的尾
    //    需要保证 0 <= size(front) - size(back) <= 1
    //    插入数据先于平衡队列 避免平衡时出现空
    class FrontMiddleBackQueue {

        Deque<Integer> front;
        Deque<Integer> back;

        public FrontMiddleBackQueue() {
            front = new ArrayDeque<>();
            back = new ArrayDeque<>();
        }

        public void pushFront(int val) {
            front.offerFirst(val);
            if (front.size() - back.size() > 1)
                back.offerFirst(front.pollLast());
        }

        public void pushMiddle(int val) {
            if (front.size() - back.size() == 1)
                back.offerFirst(front.pollLast());
            front.offerLast(val);
        }

        public void pushBack(int val) {
            back.offerLast(val);
            if (front.size() + 1 == back.size())
                front.offerLast(back.pollFirst());
        }

        public int popFront() {
            if (front.isEmpty())
                return -1;
            if (front.size() == back.size())
                front.offerLast(back.pollFirst());
            return front.pollFirst();
        }

        public int popMiddle() {
            if (front.isEmpty())
                return -1;
            int val = front.pollLast();
            if (front.size() == back.size() - 1){
                front.offerLast(back.pollFirst());
            }
            return val;
        }

        public int popBack() {
            if (front.isEmpty())
                return -1;
            if (front.size() - back.size() == 1)
                back.offerFirst(front.pollLast());
            return back.pollLast();
        }
    }
```

### LC.2336. 无限集中的最小数字 -2023-11-29

```java
    // lc.2336. 无限集中的最小数字
    // 需要尽可能高效率地找到集合中最小的元素
    // 可以通过维护一个有序集合来实现
    // 集合是无限的 每次弹出只会弹出最小的数字 故一定满足一段序列为连续相邻数字
    // 可以维护这个起始数字 那么集合就被分成两部分
    // 集合中小于base的离散值 和 [base, inf) 的连续值 此处连续离散仅表示数字的相邻性 非数学上的连续和离散
    class SmallestInfiniteSet {

        TreeSet<Integer> set;
        int base;

        public SmallestInfiniteSet() {
            set = new TreeSet<>();
            base = 1;
        }

        public int popSmallest() {
            if (set.isEmpty())
                return base++;
            return set.pollFirst();
        }

        public void addBack(int num) {
            if (num < base)
                set.add(num);
        }
    }
```

### LC.1657. 确定两个字符串是否接近 -2023-11-30

```java
    // lc.1657. 确定两个字符串是否接近
    // 给的两个操作 一个交换位置 一个字符替换(必须有这个字符)
    // 只要两个字符串包含的字符种类一致 且 字符出现频次 的频次 一致即可通过多次上述操作即可变为相同字符串
    // 优化的点就在于种类的比较 以及频次的频次比较
    public boolean closeStrings(String word1, String word2) {
        int n1 = word1.length(), n2 = word2.length();
        if (n1 != n2)
            return false;
        int[] count1 = new int[26];
        int[] count2 = new int[26];
        int charset1 = 0;
        int charset2 = 0;
        char[] chars1 = word1.toCharArray();
        char[] chars2 = word2.toCharArray();
        for (int i = 0; i < n1; i++) {
            int idx1 = chars1[i] - 'a';
            int idx2 = chars2[i] - 'a';
            charset1 |= (1 << idx1);
            charset2 |= (1 << idx2);
            count1[idx1]++;
            count2[idx2]++;
        }
        if((charset1 ^ charset2) != 0)
            return false;
        Arrays.sort(count1);
        Arrays.sort(count2);
        for (int i = 25; i >= 0; i--)
            if (count1[i] != count2[i])
                return false;
        return true;
//        HashMap<Integer, Integer> map = new HashMap<>();
//        for (int i = 0; i < 26; i++) {
//            int cnt1 = count1[i];
//            int cnt2 = count2[i];
//            if(cnt1 != 0)
//                map.put(cnt1, map.getOrDefault(cnt1, 0) + 1);
//            if(cnt2 != 0)
//                map.put(cnt2, map.getOrDefault(cnt2, 0) - 1);
//        }
//        for(int v: map.values())
//            if (v != 0)
//                return false;
//        return true;
    }
```

### LC.2661. 找出叠涂元素 -2023-12-01

```java
    // lc.2661. 找出叠涂元素
    // 按arr的顺序对mat对应数字所在位置涂色
    // 直到mat某一列或某一行全被涂色为止
    // 可以记录 第i行 和 第j列 未被涂色的位置个数 记录为 cntRow[i] 和 cntCol[j]
    // 同时最多 m*n - max(n,m) + 1 个数之后必然存在结果
    // 如果想速度再快一点可以用数索引来替代哈希表
    public int firstCompleteIndex(int[] arr, int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int total = arr.length;
//        HashMap<Integer, int[]> map = new HashMap<>();
        int[][] map = new int[total + 1][2];
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                map[mat[i][j]] = new int[]{i, j};
//                map.put(mat[i][j], new int[]{i, j});
        int[] cntRow = new int[m];
        int[] cntCol = new int[n];
        for (int i = 0; i < total; i++) {
            int[] position = map[arr[i]];
//            int[] position = map.get(arr[i]);
            int row = position[0], col = position[1];
            if (++cntRow[row] == n)
                return i;
            if (++cntCol[col] == m)
                return i;
        }
        return  -1;
    }
```

### LC.1094. 拼车 -2023-12-02

```java
    // lc.1094. 拼车
    // 记录到位置i的人数变化
    public boolean carPooling(int[][] trips, int capacity) {
        int desMax = 0;
        for (int[] trip: trips)
            desMax = Math.max(desMax, trip[2]);
        int[] diff = new int[desMax + 1];
        for (int[] trip: trips) {
            diff[trip[1]] += trip[0];
            diff[trip[2]] -= trip[0];
        }
        for (int i = 0; i < desMax; i++) {
            capacity -= diff[i];
            if (capacity < 0)
                return false;
        }
        return true;
    }
```

### LC.1423. 可获得的最大点数 -2023-12-03

```java
    // lc.1423. 可获得的最大点数
    // 实际上只有k + 1种选法 一侧的可选的卡片数取值为[0-k]
    // 可以遍历这k + 1种选法即可得到最大值
    // 还有从反面做的思路:
    // 从两侧拿的最大值可以转化为中间连续的最小值 即 n - k 个连续数字和的最小值
    // 那就将窗口值固定为 n - k 然后遍历完数组即可
    public int maxScore(int[] cardPoints, int k) {
        int n = cardPoints.length;
        int sum = 0;
        for (int i = 0; i < k; i++)
            sum += cardPoints[i];
        int ans = sum;
        for (int i = 1; i <= k; i++) {
            sum += cardPoints[n-i] - cardPoints[k-i];
            ans = Math.max(ans, sum);
        }
        return ans;
    }
```

### LC.1038. 从二叉搜索树到更大和树 -2023-12-04

```java
    // lc.1038. 从二叉搜索树到更大和树
    // 二叉搜索树的中序遍历即为自然升序 为了更好的修改每个节点的值
    // 采用逆中序遍历的方式遍历该树 得到降序序列
    // 根据前缀和来修改当前节点的值即可
    int bstSum = 0;
    public TreeNode bstToGst(TreeNode root) {
        dfsSum(root);
        return root;
    }

    public void dfsSum(TreeNode root){
        if (root == null)
            return;
        dfsSum(root.right);
        bstSum += root.val;
        root.val = bstSum;
        dfsSum(root.left);
    }
```







### LC.2477. 到达首都的最少油耗 -2023-12-05

```java
    // lc.2477. 到达首都的最少油耗
    // 所有非0节点都要到达0节点 实际上每个节点到0节点的路径是固定的
    // 区别在于该路径上有多少辆车 n人乘坐一辆车可以使得 原本的n的代价转化为1 从而节省油耗
    // 那么就需要尽可能地坐车 使得一段路径的消耗减少
    // dfs统计每段路径的消耗即可 统计子节点到当前节点的消耗
    // 每个子节点到当前节点对应一段路径 该路径的油耗为 (pathCnt / seats) 向上取整
    long ans = 0;
    public long minimumFuelCost(int[][] roads, int seats) {
        int n = roads.length;
        List<Integer>[] map = new List[n + 1];
        for (int i = 0; i <= n; i++)
            map[i] = new ArrayList<>();
        for(int[] road: roads){
            map[road[0]].add(road[1]);
            map[road[1]].add(road[0]);
        }
        dfs(0, -1, map, seats);
        return ans;
    }

    public int dfs(int cur, int pre, List<Integer>[] map, int seats){
        int sum = 1;
        for(int next: map[cur]){
            if (next != pre){
                int count = dfs(next, cur, map, seats);
                sum += count;
                ans += (count + seats - 1) / seats;
            }
        }
        return sum;
    }
```

### LC.2646. 最小化旅行的价格总和 -2023-12-06

```java
    // lc.2646. 最小化旅行的价格总和
    // 遍历每个旅行记录每个节点经过的次数
    // 旅行的价格总和 = Σ count[i] * price[i]
    // 由于可以改变price 那么就是找到一种选法使得sum最小
    // 对于可以不断拓展可选集 dp[i][0] 表示前i个节点构成的可选集 且在选择减半当前节点时的价格总和
    // dp[i][1] 表示前i个节点构成的可选集 且在不选择减半当前节点时的价格总和
    // dp[i][0] = Math.min(dp[i-1][0],dp[i-1][1]) + price[i] * count[i]
    // dp[i][1] = dp[[i-1][0] + price[i] / 2 * count[i]
    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {
        List<Integer>[] map = new List[n];
        for (int i = 0; i < n; i++)
            map[i] = new ArrayList<Integer>();
        for (int[] edge : edges) {
            map[edge[0]].add(edge[1]);
            map[edge[1]].add(edge[0]);
        }
        int[] count = new int[n];
        for (int[] trip : trips)
            dfs(trip[0], -1, trip[1], map, count);

        int[] ans = dp(0, -1, map, price, count);
        return Math.min(ans[0], ans[1]);
    }

    public boolean dfs(int cur, int pre, int target, List<Integer>[] map, int[] count){
        if (cur == target){
            count[cur]++;
            return true;
        }
        for(int next: map[cur]){
            if (next != pre){
                if (dfs(next, cur, target, map, count)){
                    count[cur]++;
                    return true;
                }
            }
        }
        return false;
    }

    public int[] dp(int cur, int pre, List<Integer>[] map, int[] price, int[] count){
        int[] res = new int[]{price[cur] * count[cur], price[cur] * count[cur] / 2};
        for(int next: map[cur]){
            if (next != pre){
                int[] sum = dp(next, cur, map, price, count);
                res[0] += Math.min(sum[0], sum[1]);
                res[1] += sum[0];
            }
        }
        return res;
    }
```

### LC.1466. 重新规划路线 -2023-12-07

```java
    // lc.1466. 重新规划路线
    // 类似前两天的每日一题
    // 假设双向联通来进行遍历 然后统计反向的个数即可
    public int minReorder(int n, int[][] connections) {
        List<int[]>[] map = new List[n];
        for (int i = 0; i < n; i++)
            map[i] = new ArrayList<>();
        for(int[] edge: connections){
            map[edge[0]].add(new int[]{edge[1], 1});
            map[edge[1]].add(new int[]{edge[0], 0});
        }
        return dfs(0, -1, map);
    }

    public int dfs(int cur, int pre, List<int[]>[] map){
        int sum = 0;
        for(int[] edge: map[cur]){
            if (edge[0] != pre)
                sum += edge[1] + dfs(edge[0], cur, map);
        }
        return sum;
    }
```





